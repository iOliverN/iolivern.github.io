<!doctype html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>iter.json: A Powerful and Efficient Way to Iterate and Manipulate JSON in Go | Oliver Nguyen</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="robots" content="all,follow"><meta name="googlebot" content="index,follow,snippet,archive"><meta name="og:site_name" content="Oliver Nguyen"><meta property="og:title" content="iter.json: A Powerful and Efficient Way to Iterate and Manipulate JSON in Go"><meta property="og:description" content="Have you ever needed to modify unstructured JSON data in Go? Maybe you’ve had to delete password and all blacklisted fields, rename keys from camelCase to snake_case, or convert all number ids to strings because JavaScript does not like int64? If your solution has been to unmarshal everything into a map[string]any using encoding/json and then marshal it back&hellip; well, let’s face it, that’s far from efficient!
What if you could loop through the JSON data, grab the path of each item, and decide exactly what to do with it on the fly?"><meta property="og:type" content="article"><meta property="og:url" content="https://iOliverNguyen.github.io/w/iter.json/"><meta property="og:image" content="https://iOliverNguyen.github.io/images/ogx.png"><meta property="article:section" content="w"><meta property="article:published_time" content="2024-12-12T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-12T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://iOliverNguyen.github.io/images/ogx.png"><meta name="twitter:title" content="iter.json: A Powerful and Efficient Way to Iterate and Manipulate JSON in Go"><meta name="twitter:description" content="Have you ever needed to modify unstructured JSON data in Go? Maybe you’ve had to delete password and all blacklisted fields, rename keys from camelCase to snake_case, or convert all number ids to strings because JavaScript does not like int64? If your solution has been to unmarshal everything into a map[string]any using encoding/json and then marshal it back&hellip; well, let’s face it, that’s far from efficient!
What if you could loop through the JSON data, grab the path of each item, and decide exactly what to do with it on the fly?"><link rel="stylesheet" href="https://iOliverNguyen.github.io/css/style-classic.css"><link rel="stylesheet" href="https://iOliverNguyen.github.io/style.css"><link rel="icon" type="image/png" href="/images/favicon.png"><link href="https://iOliverNguyen.github.io/w/iter.json/index.xml" rel="alternate" type="application/rss+xml" title="Oliver Nguyen"><script async src="https://www.googletagmanager.com/gtag/js?id=G-L5X8RJDCLM"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-L5X8RJDCLM")</script><script src="/script.js"></script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">iter.json: A Powerful and Efficient Way to Iterate and Manipulate JSON in Go</h1><div class="meta"><div class="postdate"><time datetime="2024-12-12 00:00:00 &#43;0000 UTC" itemprop="datePublished">2024-12-12</time></div><div class="article-tag">&nbsp;·&nbsp; <a class="tag-link" href="/w/#go" rel="tag">go</a></div>&nbsp;·&nbsp;&nbsp;<a href="#subscribe">subscribe to my posts</a></div></header><div class="content" itemprop="articleBody"><p><em>Have you ever needed to modify unstructured JSON data in Go? Maybe you’ve had to delete password and all blacklisted fields, rename keys from <code>camelCase</code> to <code>snake_case</code>, or convert all number ids to strings because JavaScript does not like <code>int64</code>? If your solution has been to unmarshal everything into a <code>map[string]any</code> using <code>encoding/json</code> and then marshal it back&hellip; well, let’s face it, that’s far from efficient!</em></p><p><em>What if you could loop through the JSON data, grab the path of each item, and decide exactly what to do with it on the fly?</em></p><p><em>Yes! I have a good news! With the new iterator feature in Go 1.23, there’s a better way to iterate and manipulate JSON.<br>Meet <a href="https://ezpkg.io/iter.json">ezpkg.io/iter.json</a> — your powerful and efficient companion for working with JSON in Go.</em></p><hr><h2 id="hello-world">Hello World!</h2><p><a href="https://ezpkg.io/iter.json">ezpkg.io/iter.json</a> is a Go package that provides a simple and efficient way to iterate over JSON data. It allows you to traverse JSON objects, arrays, and values, and perform various operations on them without fully parsing the data.</p><p>At the core, it provides a <a href="https://pkg.go.dev/ezpkg.io/iter.json#Parse">Parse()</a> function and a <a href="https://pkg.go.dev/ezpkg.io/iter.json#Builder">Builder</a> type. The <code>Parse()</code> function returns <a href="https://pkg.go.dev/iter#hdr-Iterators">an iterator</a> that yields each item in the JSON data, while the <code>Builder</code> type allows you to build new JSON data dynamically.</p><p>Let&rsquo;s look at some examples of how to use <a href="https://ezpkg.io/iter.json">iter.json</a> to iterate, build, format, filter, and edit JSON data in Go.</p><h3 id="1-iterating-json">1. Iterating JSON</h3><p>Given that we have an <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/alice.json">alice.json</a> file:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Alice&#34;</span><span class="p">,</span>
  <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span>
  <span class="nt">&#34;scores&#34;</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
  <span class="nt">&#34;address&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;city&#34;</span><span class="p">:</span> <span class="s2">&#34;The Sun&#34;</span><span class="p">,</span>
    <span class="nt">&#34;zip&#34;</span><span class="p">:</span> <span class="mi">10101</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>First, let&rsquo;s use <code>for range</code> <a href="https://pkg.go.dev/ezpkg.io/iter.json#Parse">Parse()</a> to iterate over the JSON file, then print the path, key, token, and level of each item. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/01.iter/main.go">examples/01.iter</a>.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>

    <span class="s">&#34;ezpkg.io/errorz&#34;</span>
    <span class="nx">iterjson</span> <span class="s">&#34;ezpkg.io/iter.json&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="s">`{&#34;name&#34;: &#34;Alice&#34;, &#34;age&#34;: 24, &#34;scores&#34;: [9, 10, 8], &#34;address&#34;: {&#34;city&#34;: &#34;The Sun&#34;, &#34;zip&#34;: 10101}}`</span>

    <span class="c1">// 🎄Example: iterate over json
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;| %12v | %10v | %10v |%v|\n&#34;</span><span class="p">,</span> <span class="s">&#34;PATH&#34;</span><span class="p">,</span> <span class="s">&#34;KEY&#34;</span><span class="p">,</span> <span class="s">&#34;TOKEN&#34;</span><span class="p">,</span> <span class="s">&#34;LVL&#34;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;| ------------ | ---------- | ---------- | - |&#34;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;| %12v | %10v | %10v | %v |\n&#34;</span><span class="p">,</span> 
            <span class="nx">item</span><span class="p">.</span><span class="nf">GetPathString</span><span class="p">(),</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Level</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>The code will output:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">|         PATH |        KEY |      TOKEN |LVL|
| ------------ | ---------- | ---------- | - |
|              |            |          { | 0 |
|         name |     &#34;name&#34; |    &#34;Alice&#34; | 1 |
|          age |      &#34;age&#34; |         24 | 1 |
|       scores |   &#34;scores&#34; |          [ | 1 |
|     scores.0 |            |          9 | 2 |
|     scores.1 |            |         10 | 2 |
|     scores.2 |            |          8 | 2 |
|       scores |            |          ] | 1 |
|      address |  &#34;address&#34; |          { | 1 |
| address.city |     &#34;city&#34; |  &#34;The Sun&#34; | 2 |
|  address.zip |      &#34;zip&#34; |      10101 | 2 |
|      address |            |          } | 1 |
|              |            |          } | 0 |
</code></pre></div><h3 id="2-building-json">2. Building JSON</h3><p>Use <code>Builder</code> to build a JSON data. It accepts optional arguments for indentation. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/02.builder/main.go">examples/02.builder</a>.</p><ul><li>Create a new <code>Builder</code> with <code>NewBuilder(prefix, indent string)</code>.</li><li><code>Builder.AddRaw(key RawToken, token RawToken)</code> adds a raw token to the JSON data.</li><li><code>Builder.Add(key any, token any)</code> adds a key-value pair to the JSON data.</li><li><code>Builder.Bytes()</code> returns the JSON data as a byte slice.</li><li>It accepts various types, including <code>string</code>, <code>int</code>, <code>struct</code>, <code>[]byte</code>, etc.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
<span class="c1">// open an object
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nx">TokenObjectOpen</span><span class="p">)</span>

<span class="c1">// add a few fields
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Alice&#34;</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;age&#34;</span><span class="p">,</span> <span class="mi">22</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;email&#34;</span><span class="p">,</span> <span class="s">&#34;alice@example.com&#34;</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;phone&#34;</span><span class="p">,</span> <span class="s">&#34;(+84) 123-456-789&#34;</span><span class="p">)</span>

<span class="c1">// open an array
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;languages&#34;</span><span class="p">,</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nx">TokenArrayOpen</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;English&#34;</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;Vietnamese&#34;</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nx">TokenArrayClose</span><span class="p">)</span>
<span class="c1">// close the array
</span><span class="c1"></span>
<span class="c1">// accept any type that can marshal to json
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;address&#34;</span><span class="p">,</span> <span class="nx">Address</span><span class="p">{</span>
    <span class="nx">HouseNumber</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
    <span class="nx">Street</span><span class="p">:</span>      <span class="s">&#34;Ly Thuong Kiet&#34;</span><span class="p">,</span>
    <span class="nx">City</span><span class="p">:</span>        <span class="s">&#34;Ha Noi&#34;</span><span class="p">,</span>
    <span class="nx">Country</span><span class="p">:</span>     <span class="s">&#34;Vietnam&#34;</span><span class="p">,</span>
<span class="p">})</span>

<span class="c1">// accept []byte as raw json
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;pets&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`[{&#34;type&#34;:&#34;cat&#34;,&#34;name&#34;:&#34;Kitty&#34;,&#34;age&#34;:2},{&#34;type&#34;:&#34;dog&#34;,&#34;name&#34;:&#34;Yummy&#34;,&#34;age&#34;:3}]`</span><span class="p">))</span>

<span class="c1">// close the object
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nx">TokenObjectClose</span><span class="p">)</span>

<span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- build json ---\n%s\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
</code></pre></div><p>Which will output the JSON with indentation:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Alice&#34;</span><span class="p">,</span>
    <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span>
    <span class="nt">&#34;email&#34;</span><span class="p">:</span> <span class="s2">&#34;alice@example.com&#34;</span><span class="p">,</span>
    <span class="nt">&#34;phone&#34;</span><span class="p">:</span> <span class="s2">&#34;(+84) 123-456-789&#34;</span><span class="p">,</span>
    <span class="nt">&#34;languages&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&#34;English&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Vietnamese&#34;</span>
    <span class="p">],</span>
    <span class="nt">&#34;address&#34;</span><span class="p">:</span> <span class="p">{</span><span class="nt">&#34;house_number&#34;</span><span class="p">:</span><span class="mi">42</span><span class="p">,</span><span class="nt">&#34;street&#34;</span><span class="p">:</span><span class="s2">&#34;Ly Thuong Kiet&#34;</span><span class="p">,</span><span class="nt">&#34;city&#34;</span><span class="p">:</span><span class="s2">&#34;Ha Noi&#34;</span><span class="p">,</span><span class="nt">&#34;country&#34;</span><span class="p">:</span><span class="s2">&#34;Vietnam&#34;</span><span class="p">},</span>
    <span class="nt">&#34;pets&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;cat&#34;</span><span class="p">,</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Kitty&#34;</span><span class="p">,</span>
            <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">2</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;dog&#34;</span><span class="p">,</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Yummy&#34;</span><span class="p">,</span>
            <span class="nt">&#34;age&#34;</span><span class="p">:</span> <span class="mi">3</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h3 id="3-formatting-json">3. Formatting JSON</h3><p>You can reconstruct or format a JSON data by sending its key and values to a <code>Builder</code>. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/03.reformat/main.go">examples/03.reformat</a>.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span>
    <span class="c1">// 🐝Example: minify json
</span><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">AddRaw</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- minify ---\n%s\n----------\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">{</span>
    <span class="c1">// 🦋Example: format json
</span><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;👉   &#34;</span><span class="p">,</span> <span class="s">&#34;\t&#34;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">AddRaw</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- reformat ---\n%s\n----------\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>The first example minifies the JSON while the second example formats it with prefix &ldquo;👉&rdquo; on each line.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">--- minify ---
{&#34;name&#34;:&#34;Alice&#34;,&#34;age&#34;:24,&#34;scores&#34;:[9,10,8],&#34;address&#34;:{&#34;city&#34;:&#34;The Sun&#34;,&#34;zip&#34;:10101}}
----------

--- reformat ---
👉   {
👉       &#34;name&#34;: &#34;Alice&#34;,
👉       &#34;age&#34;: 24,
👉       &#34;scores&#34;: [
👉           9,
👉           10,
👉           8
👉       ],
👉       &#34;address&#34;: {
👉           &#34;city&#34;: &#34;The Sun&#34;,
👉           &#34;zip&#34;: 10101
👉       }
👉   }
----------
</code></pre></div><h3 id="4-adding-line-numbers">4. Adding line numbers</h3><p>In this example, we add line numbers to the JSON output, by adding a <code>b.WriteNewline()</code> before the <code>fmt.Fprintf()</code> call. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/04.line_number/main.go">examples/04.line_number</a>.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 🐞Example: print with line number
</span><span class="c1"></span><span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>

    <span class="c1">// 👉 add line number
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="s">&#34;%3d    &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- line number ---\n%s\n----------\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
</code></pre></div><p>This will output:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">  1    {
  2        &#34;name&#34;: &#34;Alice&#34;,
  3        &#34;age&#34;: 24,
  4        &#34;scores&#34;: [
  5            9,
  6            10,
  7            8
  8        ],
  9        &#34;address&#34;: {
 10            &#34;city&#34;: &#34;The Sun&#34;,
 11            &#34;zip&#34;: 10101
 12        }
 13    }
</code></pre></div><h3 id="5-adding-comments">5. Adding comments</h3><p>By putting a <code>fmt.Fprintf(comment)</code> between <code>b.WriteComma()</code> and <code>b.WriteNewline()</code>, you can add a comment to the end of each line. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/05.comment/main.go">examples/05.comment</a>.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">i</span><span class="p">,</span> <span class="nx">newlineIdx</span><span class="p">,</span> <span class="nx">maxIdx</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">30</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteComma</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>

    <span class="c1">// 👉 add comment
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">length</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">-</span> <span class="nx">newlineIdx</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Repeat</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nx">maxIdx</span><span class="o">-</span><span class="nx">length</span><span class="p">))</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="s">&#34;// %2d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">i</span><span class="o">++</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
    <span class="nx">newlineIdx</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="c1">// save the newline index
</span><span class="c1"></span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">length</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">-</span> <span class="nx">newlineIdx</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Repeat</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nx">maxIdx</span><span class="o">-</span><span class="nx">length</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="s">&#34;// %2d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>

<span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- comment ---\n%s\n----------\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
</code></pre></div><p>This will output:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">{                             //  1
    &#34;name&#34;: &#34;Alice&#34;,          //  2
    &#34;age&#34;: 24,                //  3
    &#34;scores&#34;: [               //  4
        9,                    //  5
        10,                   //  6
        8                     //  7
    ],                        //  8
    &#34;address&#34;: {              //  9
        &#34;city&#34;: &#34;The Sun&#34;,    // 10
        &#34;zip&#34;: 10101          // 11
    }                         // 12
}                             // 13
</code></pre></div><h3 id="6-filtering-json-and-extracting-values">6. Filtering JSON and extracting values</h3><p>There are <code>item.GetPathString()</code> and <code>item.GetRawPath()</code> to get the path of the current item. You can use them to filter the JSON data. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/06.filter_print/main.go">examples/06.filter_print</a>.</p><p>Example with <code>item.GetPathString()</code> and <code>regexp</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- filter: GetPathString() ---\n&#34;</span><span class="p">)</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

    <span class="nx">path</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.</span><span class="nf">GetPathString</span><span class="p">()</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">path</span> <span class="o">==</span> <span class="s">&#34;name&#34;</span><span class="p">,</span>
        <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="s">&#34;address&#34;</span><span class="p">):</span>
        <span class="c1">// continue
</span><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="p">}</span>

    <span class="c1">// 👉 print with line number
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%2d %20s . %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nf">GetPath</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>Example with <code>item.GetRawPath()</code> and <code>path.Match()</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- filter: GetRawPath() ---\n&#34;</span><span class="p">)</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

    <span class="nx">path</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.</span><span class="nf">GetRawPath</span><span class="p">()</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Match</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">),</span>
        <span class="nx">path</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">&#34;address&#34;</span><span class="p">):</span>
        <span class="c1">// continue
</span><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="p">}</span>

    <span class="c1">// 👉 print with line number
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%2d %20s . %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nf">GetPath</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>Both examples will output:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"> 2              &#34;Alice&#34; . name
 9                    { . address
10            &#34;The Sun&#34; . address.city
11                10101 . address.zip
12                    } . address
</code></pre></div><h3 id="7-filtering-json-and-returning-a-new-json">7. Filtering JSON and returning a new JSON</h3><p>By combining the <code>Builder</code> with the option <code>SetSkipEmptyStructures(false)</code> and the filtering logic, you can filter the JSON data and return a new JSON. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/07.filter_json/main.go">examples/07.filter_json</a></p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 🦁Example: filter and output json
</span><span class="c1"></span><span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nf">SetSkipEmptyStructures</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 👉 skip empty [] or {}
</span><span class="c1"></span><span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">IsOpen</span><span class="p">()</span> <span class="o">||</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">IsClose</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="p">}</span>

    <span class="nx">path</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.</span><span class="nf">GetPathString</span><span class="p">()</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">path</span> <span class="o">==</span> <span class="s">&#34;name&#34;</span><span class="p">,</span>
        <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="s">&#34;address&#34;</span><span class="p">):</span>
        <span class="c1">// continue
</span><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="p">}</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- filter: output json ---\n%s\n----------\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
</code></pre></div><p>This example will return a new JSON with only the filtered fields:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Alice&#34;</span><span class="p">,</span>
    <span class="nt">&#34;address&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;city&#34;</span><span class="p">:</span> <span class="s2">&#34;The Sun&#34;</span><span class="p">,</span>
        <span class="nt">&#34;zip&#34;</span><span class="p">:</span> <span class="mi">10101</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="8-editing-values">8. Editing values</h3><p>This is an example for editing values in a JSON data. Assume that we are using number ids for our API. The ids are too big and JavaScript can&rsquo;t handle them. We need to convert them to strings. See <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/08.number_id/main.go">examples/08.number_id</a> and <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/examples/order.json">order.json</a>.</p><p>Iterate over the JSON data, find all <code>_id</code> fields and convert the number ids to strings:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">NewBuilder</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">key</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.</span><span class="nf">GetRawPath</span><span class="p">().</span><span class="nf">Last</span><span class="p">().</span><span class="nf">ObjectKey</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasSuffix</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;_id&#34;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">id</span><span class="p">,</span> <span class="nx">err0</span> <span class="o">:=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">GetInt</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err0</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">out</span> <span class="o">:=</span> <span class="nx">errorz</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n--- convert number id ---\n%s\n----------\n&#34;</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
</code></pre></div><p>This will add quotes to the number ids:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;order_id&#34;</span><span class="p">:</span> <span class="s2">&#34;12345678901234&#34;</span><span class="p">,</span>
    <span class="nt">&#34;number&#34;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
    <span class="nt">&#34;customer_id&#34;</span><span class="p">:</span> <span class="s2">&#34;12345678905678&#34;</span><span class="p">,</span>
    <span class="nt">&#34;items&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;item_id&#34;</span><span class="p">:</span> <span class="s2">&#34;12345678901042&#34;</span><span class="p">,</span>
            <span class="nt">&#34;quantity&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nt">&#34;price&#34;</span><span class="p">:</span> <span class="mf">123.45</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="nt">&#34;item_id&#34;</span><span class="p">:</span> <span class="s2">&#34;12345678901098&#34;</span><span class="p">,</span>
            <span class="nt">&#34;quantity&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nt">&#34;price&#34;</span><span class="p">:</span> <span class="mf">234.56</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><hr><h2 id="how-it-parses-the-json-data">How it parses the JSON data</h2><p>Thanks to powerful of iterators in Go 1.23, <a href="https://ezpkg.io/iter.json">ezpkg.io/iter.json</a> is able to process JSON data with minimal lines of code and low overhead.</p><p>The core parser logic is contained in 2 files: <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/scanner.go">scanner.go</a> and <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/parser.go">parser.go</a>. Here’s a brief overview of how it works:</p><ul><li><a href="https://pkg.go.dev/ezpkg.io/iter.json#NextToken">NextToken()</a> pulls the next <a href="https://pkg.go.dev/ezpkg.io/iter.json#RawToken">RawToken</a> from the input.</li><li><a href="https://pkg.go.dev/ezpkg.io/iter.json#Parse">Parse()</a> is a state machine with a stack. It pulls the next token from the input then processes it based on the current state.</li><li><a href="https://pkg.go.dev/ezpkg.io/iter.json#RawToken">RawToken()</a> is a tagged union with a <a href="https://pkg.go.dev/ezpkg.io/iter.json#TokenType">TokenType</a> and optional raw <code>[]byte</code>.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RawToken represents a raw token from the scanner.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RawToken</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">typ</span> <span class="nx">TokenType</span>
    <span class="nx">raw</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><h3 id="nexttoken-pulls-the-next-token-from-the-input">NextToken() pulls the next token from the input</h3><p>Here&rsquo;s the core logic of the <a href="https://pkg.go.dev/ezpkg.io/iter.json#NextToken">NextToken()</a> function (<a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/scanner.go">scanner.go</a>):</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NextToken</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">token</span> <span class="nx">RawToken</span><span class="p">,</span> <span class="nx">remain</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">in</span> <span class="p">=</span> <span class="nf">skipSpace</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">RawToken</span><span class="p">{},</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;{&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">:</span>
        <span class="nx">typ</span> <span class="o">:=</span> <span class="nf">TokenType</span><span class="p">(</span><span class="nx">in</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="nx">RawToken</span><span class="p">{</span><span class="nx">typ</span><span class="p">:</span> <span class="nx">typ</span><span class="p">,</span> <span class="nx">raw</span><span class="p">:</span> <span class="nx">in</span><span class="p">[:</span><span class="mi">1</span><span class="p">]},</span> <span class="nx">in</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="kc">nil</span>
    <span class="k">case</span> <span class="sc">&#39;n&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">nextTokenConst</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">rNull</span><span class="p">)</span>
    <span class="k">case</span> <span class="sc">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">nextTokenConst</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">rFalse</span><span class="p">)</span>
    <span class="k">case</span> <span class="sc">&#39;t&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">nextTokenConst</span><span class="p">(</span><span class="nx">in</span><span class="p">,</span> <span class="nx">rTrue</span><span class="p">)</span>
    <span class="k">case</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">nextTokenString</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">nextTokenNumber</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="scan-all-tokens-in-a-single-loop">Scan() all tokens in a single loop</h3><p>The <a href="https://pkg.go.dev/ezpkg.io/iter.json#Scan">Scan()</a> function is essentially a single loop to pull the next token from the input each time.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">Seq2</span><span class="p">[</span><span class="nx">RawToken</span><span class="p">,</span> <span class="kt">error</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">yield</span> <span class="kd">func</span><span class="p">(</span><span class="nx">token</span> <span class="nx">RawToken</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">remain</span> <span class="o">:=</span> <span class="nx">in</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">token</span><span class="p">,</span> <span class="nx">rm</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NextToken</span><span class="p">(</span><span class="nx">remain</span><span class="p">)</span>
            <span class="nx">remain</span> <span class="p">=</span> <span class="nx">rm</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">yield</span><span class="p">(</span><span class="nx">RawToken</span><span class="p">{},</span> <span class="nx">err</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">!</span><span class="nf">yield</span><span class="p">(</span><span class="nx">token</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">remain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="parse-is-a-state-machine-with-a-stack">Parse() is a state machine with a stack</h3><p>Here&rsquo;s the core logic of the parser (<a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/parser.go">parse.go</a>).</p><ul><li>It uses a stack to keep track of the current state (path, level) of the JSON data.</li><li>It pulls the next token from the input and processes it based on the current state:<ul><li>If it&rsquo;s <code>[</code> or <code>{</code>, it pushes the current state to the stack.</li><li>If it&rsquo;s <code>]</code> or <code>}</code>, it pops the state from the stack.</li><li>Otherwise, it parses &ldquo;value&rdquo; or &ldquo;key: value&rdquo; depending on the current state.</li></ul></li></ul><p>Here&rsquo;s how it initializes the stack:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">path</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">PathItem</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="nx">last</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div><p>With the implementation of <a href="https://pkg.go.dev/ezpkg.io/iter.json#PathItem">PathItem</a>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PathItem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Index</span> <span class="kt">int</span>      <span class="c1">// array index or object index
</span><span class="c1"></span>    <span class="nx">Key</span>   <span class="nx">RawToken</span> <span class="c1">// object key
</span><span class="c1"></span>    <span class="nx">Token</span> <span class="nx">RawToken</span> <span class="c1">// [ or { or } or ]
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>And the <code>push()</code>, <code>pop()</code>, <code>advance()</code> helper functions:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">advance</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="nx">tok</span> <span class="p">=</span> <span class="nx">next</span>
    <span class="nx">next</span><span class="p">,</span> <span class="nx">remain</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">NextToken</span><span class="p">(</span><span class="nx">remain</span><span class="p">)</span>
    <span class="nf">must</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">push</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">PathItem</span><span class="p">{</span><span class="nx">Token</span><span class="p">:</span> <span class="nx">tok</span><span class="p">})</span>
    <span class="nx">last</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">pop</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="nx">last</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>The core state machine code is as follows. Honestly, using <code>goto</code> in this case is quite fun:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">Seq2</span><span class="p">[</span><span class="nx">Item</span><span class="p">,</span> <span class="kt">error</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">yield</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Item</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}()</span>

        <span class="kd">var</span> <span class="nx">tok</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">RawToken</span>
        <span class="nx">remain</span> <span class="o">:=</span> <span class="nx">in</span>
        <span class="nx">path</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">PathItem</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">last</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">advance</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
        <span class="nx">push</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
        <span class="nx">pop</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
        <span class="nx">yieldValue</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="nx">RawToken</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
        <span class="nf">advance</span><span class="p">()</span>
        <span class="nf">advance</span><span class="p">()</span>
    <span class="nx">value</span><span class="p">:</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenArrayOpen</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">!</span><span class="nf">yieldValue</span><span class="p">(</span><span class="nx">last</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">push</span><span class="p">()</span>
            <span class="nf">advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenArrayClose</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">close</span> <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">value</span> <span class="p">}</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenObjectOpen</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">!</span><span class="nf">yieldValue</span><span class="p">(</span><span class="nx">last</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">push</span><span class="p">()</span>
            <span class="nf">advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenObjectClose</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">close</span> <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">key_value</span> <span class="p">}</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nf">IsValue</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">!</span><span class="nf">yieldValue</span><span class="p">(</span><span class="nx">last</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="k">switch</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">last</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="c1">// ✅ done
</span><span class="c1"></span>            <span class="k">case</span> <span class="nx">last</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span><span class="p">.</span><span class="nx">typ</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="nf">advance</span><span class="p">()</span>
                <span class="k">goto</span> <span class="nx">close</span>
            <span class="p">}</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="nx">key_value</span><span class="p">:</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenString</span><span class="p">:</span>
            <span class="nx">last</span><span class="p">.</span><span class="nx">Key</span> <span class="p">=</span> <span class="nx">tok</span>
            <span class="nf">advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenColon</span> <span class="p">{</span>
                <span class="nf">advance</span><span class="p">()</span>
                <span class="k">goto</span> <span class="nx">value</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="nx">close</span><span class="p">:</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenArrayClose</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">last</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nx">typ</span> <span class="o">!=</span> <span class="nx">TokenArrayOpen</span> <span class="p">{</span> <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">}</span>
            <span class="nf">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">!</span><span class="nf">yieldValue</span><span class="p">(</span><span class="nx">RawToken</span><span class="p">{})</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">close</span> <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">end</span> <span class="p">}</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenObjectClose</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">last</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nx">typ</span> <span class="o">!=</span> <span class="nx">TokenObjectOpen</span> <span class="p">{</span> <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">}</span>
            <span class="nf">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">!</span><span class="nf">yieldValue</span><span class="p">(</span><span class="nx">RawToken</span><span class="p">{})</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">close</span> <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span> <span class="k">goto</span> <span class="nx">end</span>    <span class="p">}</span>
        <span class="k">case</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenComma</span><span class="p">:</span>
            <span class="nx">last</span><span class="p">.</span><span class="nx">Index</span><span class="o">++</span>
            <span class="nx">last</span><span class="p">.</span><span class="nx">Key</span> <span class="p">=</span> <span class="nx">RawToken</span><span class="p">{}</span>
            <span class="nf">advance</span><span class="p">()</span>
            <span class="k">switch</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">last</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenArrayOpen</span><span class="p">:</span>
                <span class="k">goto</span> <span class="nx">value</span>
            <span class="k">case</span> <span class="nx">last</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="nx">TokenObjectOpen</span><span class="p">:</span>
                <span class="k">goto</span> <span class="nx">key_value</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="nx">end</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">typ</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">panic</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="how-it-builds-the-json-data-dynamically">How it builds the JSON data dynamically</h2><p>Implementing a <a href="https://pkg.go.dev/ezpkg.io/iter.json#Builder">Builder</a> with essentially only a single method <code>Add(key any, value any)</code> produce valid JSON is a fun challenge too!</p><h3 id="reconstructing-json-from-rawtoken">Reconstructing JSON from RawToken</h3><p>At first, let&rsquo;s look at how we can construct a JSON object from <code>RawToken</code> without using the <code>Builder</code>. Here&rsquo;s the simplest implementation by <a href="https://pkg.go.dev/ezpkg.io/iter.json#Reconstruct">Reconstruct()</a>, which produces a minified JSON:</p><ul><li>It iterates over the <code>Parse()</code> result to retrieve keys and tokens.</li><li>Tokens can be <code>[</code>, <code>{</code>, <code>]</code>, <code>}</code>, or values. Note that <code>,</code> and <code>:</code> are not returned by <code>Parse()</code>.</li><li>It writes the key and token to a buffer, adding a comma if necessary.</li><li>To correctly add commas between tokens, it needs to keep track of the last token type and call <code>ShouldAddComma()</code>.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Reconstruct</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">{}</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">Grow</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>

    <span class="kd">var</span> <span class="nx">lastTokenType</span> <span class="nx">TokenType</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">ShouldAddComma</span><span class="p">(</span><span class="nx">lastTokenType</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">.</span><span class="nf">IsValue</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">.</span><span class="nf">Raw</span><span class="p">())</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;:&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Raw</span><span class="p">())</span>
        <span class="nx">lastTokenType</span> <span class="p">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>And the <code>ShouldAddComma()</code> function:</p><ul><li>Skip the comma the last token is <code>[</code>, <code>{</code>, <code>,</code>, or <code>:</code> or the next token is <code>]</code> or <code>}</code>.</li><li>Otherwise, add the comma.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ShouldAddComma</span><span class="p">(</span><span class="nx">lastToken</span><span class="p">,</span> <span class="nx">nextToken</span> <span class="nx">TokenType</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">lastToken</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">TokenArrayOpen</span><span class="p">,</span> <span class="nx">TokenObjectOpen</span><span class="p">,</span> <span class="nx">TokenComma</span><span class="p">,</span> <span class="nx">TokenColon</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">nextToken</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">TokenArrayClose</span><span class="p">,</span> <span class="nx">TokenObjectClose</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="how-to-support-indentation">How to support indentation</h3><p>To support indentation, we need to keep track of the current level and add the appropriate number of spaces before each line. Here&rsquo;s how we can modify the <code>Reconstruct()</code> function to support indentation:</p><ul><li>Add <code>prefix</code> and <code>indent</code> arguments to the function.</li><li>Add the <code>prefix</code> before each line.</li><li>Add the <code>indent</code> for each level of indentation.</li><li>Use the <code>Level</code> from the <code>Parse()</code> result to determine the indentation level.</li></ul><p><em>Alternatively, we can keep track of the level ourselves by incrementing and decrementing a counter for each <code>[</code>,<code>{</code> and <code>]</code>,<code>}</code>. We can also use a stack to keep track of the level, and the current path too.</em></p><p>Here&rsquo;s the modified function with indentation support as <a href="https://pkg.go.dev/ezpkg.io/iter.json#Reformat">Reformat()</a>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Reformat</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">prefix</span><span class="p">,</span> <span class="nx">indent</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">{}</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">Grow</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>

    <span class="kd">var</span> <span class="nx">lastToken</span> <span class="nx">TokenType</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">ShouldAddComma</span><span class="p">(</span><span class="nx">lastToken</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">lastToken</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span>
        <span class="k">for</span> <span class="k">range</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Level</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">indent</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">.</span><span class="nf">IsValue</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">.</span><span class="nf">Raw</span><span class="p">())</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="s">&#34;: &#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Raw</span><span class="p">())</span>
        <span class="nx">lastToken</span> <span class="p">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="early-implementation-of-builder">Early implementation of Builder</h3><p>So you get the idea of how <code>Reconstruct()</code>/<code>Reformat()</code> functions work. Now, let&rsquo;s look at how the <code>Builder</code> is implemented.</p><p>It starts with a <code>AddRaw()</code> method to add raw tokens to the JSON data. Here&rsquo;s <a href="https://github.com/ezpkg/ezpkg/commit/d643f3081a84605e24af69b15da611d29c15538d#diff-7d1cb3451ed571ba41b5108e3e92534a94c1142138d6454d2c1cc0af7511fad5R85">the early implementation</a>:</p><p>The code is basically the same as <code>Reformat()</code> but with a few differences:</p><ul><li>It keeps track of the last token type, the current level, and the stack of <code>[</code> and <code>{</code>.</li><li>To keep track of the level, it needs to switch on open or close tokens to update the stack and level.<ul><li>Instead of just a single check <code>Key.IsValue()</code> like in <code>Reformat()</code>.</li></ul></li><li>It writes the key and token to the buffer, adding a comma if necessary.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Builder</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">indent</span> <span class="kt">string</span>
    <span class="nx">prefix</span> <span class="kt">string</span>

    <span class="nx">lastTok</span> <span class="nx">TokenType</span>
    <span class="nx">level</span>   <span class="kt">int</span>
    <span class="nx">stack</span>   <span class="p">[]</span><span class="nx">TokenType</span> <span class="c1">// array or object
</span><span class="c1"></span>    <span class="nx">err</span>     <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder</span><span class="p">)</span> <span class="nf">AddRaw</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">token</span> <span class="nx">RawToken</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">token</span><span class="p">.</span><span class="nf">IsOpen</span><span class="p">():</span>
        <span class="k">if</span> <span class="nf">ShouldAddComma</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeIndent</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()))</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span> <span class="p">=</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">level</span><span class="o">++</span>

    <span class="k">case</span> <span class="nx">token</span><span class="p">.</span><span class="nf">IsClose</span><span class="p">():</span>
        <span class="k">if</span> <span class="nx">key</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">addErrorf</span><span class="p">(</span><span class="s">&#34;unexpected key(%s) before close token(%s)&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">level</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">addErrorf</span><span class="p">(</span><span class="s">&#34;unexpected close token(%s)&#34;</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">level</span><span class="o">--</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeIndent</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()))</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span> <span class="p">=</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>

    <span class="k">case</span> <span class="nx">token</span><span class="p">.</span><span class="nf">IsValue</span><span class="p">():</span>
        <span class="k">if</span> <span class="nf">ShouldAddComma</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeIndent</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nf">Raw</span><span class="p">())</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span> <span class="p">=</span> <span class="nx">token</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="twisting-builder-code-to-support-more-use-cases">Twisting <code>Builder</code> code to support more use cases</h3><p>As more use cases are added, the <code>Builder</code> code evolves and becomes more complex over time.</p><p><strong><code>WriteNewline()</code> are made public to control the position of prefix.</strong></p><p>In the example <a href="#4-adding-line-numbers">Adding line numbers</a>, notice that we have a <a href="https://pkg.go.dev/ezpkg.io/iter.json#Builder.WriteNewline"><code>b.WriteNewLine(item.Token.Type())</code></a> before the <code>fmt.Fprintf()</code> call.</p><p>This is because we need to control the position of the line number:</p><ul><li>so the line number can be added <em>after the comma and newline</em>,</li><li>but <em>before the key and token</em>.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>

    <span class="c1">// 👉 add line number
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="s">&#34;%3d    &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><code>WriteNewline()</code> is optional.</p><ul><li>If you don&rsquo;t include it, the next <code>b.Add()</code> will automatically call it.</li><li>If you do, it will be remembered and <code>b.Add()</code> will just skip the call.</li></ul><p>It&rsquo;s also smart. If the <code>Builder</code> does not have indentation configured, it will not add any newline. It won&rsquo;t add first newline, or double newlines too.</p><p>This way, the API becomes more flexible: <em>easy to use while still allowing for more advanced use cases</em>.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder</span><span class="p">)</span> <span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">next</span> <span class="nx">TokenType</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteComma</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">prefix</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">indent</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">lastNewline</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeByte</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">lastNewline</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>And <code>WriteComma()</code> for comments.</strong></p><p>The same goes for <code>WriteComma()</code>. It&rsquo;s used in the <a href="#5-adding-comments">Adding comments</a> example to control the position of the comment.</p><ul><li>Like <code>WriteNewline()</code>, <code>WriteComma()</code> is optional and smart. It will add a comma only when necessary, to always produce valid JSON.</li><li>So if you call <code>Add(&quot;&quot;, TokenObjectOpen)</code> then <code>WriteComma()</code>, it won&rsquo;t actually add any comma, otherwise the JSON will become invalid.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iterjson</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">errorz</span><span class="p">.</span><span class="nf">MustZ</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="c1">// 👉 add a comma before the comment
</span><span class="c1"></span>    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteComma</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span> 

    <span class="c1">// 👉 then add the comment
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// extra logic to control spaces and align comments
</span><span class="c1"></span>        <span class="nx">length</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">-</span> <span class="nx">newlineIdx</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Repeat</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nx">maxIdx</span><span class="o">-</span><span class="nx">length</span><span class="p">))</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="s">&#34;// %2d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">i</span><span class="o">++</span>

    <span class="c1">// 👉 and a newline after the comment
</span><span class="c1"></span>    <span class="nx">b</span><span class="p">.</span><span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
    <span class="nx">newlineIdx</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="c1">// save the newline index
</span><span class="c1"></span>
    <span class="c1">// 👉 finally, add the key and token
</span><span class="c1"></span>    <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong><code>SetSkipEmptyStructures(true)</code> to ignore empty structures.</strong></p><p>In the <a href="#7-filtering-json-and-returning-a-new-json">Filtering JSON and returning a new JSON</a> example, we use <code>SetSkipEmptyStructures(true)</code> to ignore empty structures.</p><p>Without this option, the <code>Builder</code> will add empty <code>{}</code> or <code>[]</code> to the output JSON. Try removing it and the output will become:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span>
    <span class="s">&#34;name&#34;</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">,</span>
    <span class="s">&#34;scores&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">],</span>
    <span class="s">&#34;address&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#34;city&#34;</span><span class="p">:</span> <span class="s">&#34;The Sun&#34;</span><span class="p">,</span>
        <span class="s">&#34;zip&#34;</span><span class="p">:</span> <span class="mi">10101</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Notice the empty <code>[]</code> for the <code>scores</code> field. But how does it work?</p><ul><li>To make it work, the <code>Builder</code> should not write the <code>&quot;scores&quot;: [</code> immediately when receiving the <code>[</code> token, because it doesn&rsquo;t know if there are any items inside.</li><li>Instead, it writes to an alternative buffer. And save a snapshot of the current state.</li><li>The next time a new token is <code>Add</code>ed, if it&rsquo;s empty <code>]</code>, the alternative buffer will be cleared, the previous snapshot will get restored, and the empty <code>&quot;scores&quot;</code> field will be skipped.</li><li>Otherwise, it switches back to the main buffer, including the content of the alternative buffer.</li><li>This way, the <code>Builder</code> can skip empty structures with minimal overhead.</li></ul><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder</span><span class="p">)</span> <span class="nf">SetSkipEmptyStructures</span><span class="p">(</span><span class="nx">skip</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">skipEmptyStructures</span> <span class="p">=</span> <span class="nx">skip</span>
    <span class="k">if</span> <span class="nx">skip</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">useAltBuf</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">altBuf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nx">altBuf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">switchBuf</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>And here&rsquo;s the <a href="https://github.com/ezpkg/ezpkg/blob/7df56e7f78479ab1d7d94e4a1278d61636adfe95/iter.json/reconstruct.go#L171-L200">updated implementation</a> of the <code>add()</code> method with <code>switchAltBuf()</code> and <code>restore(snapshot)</code>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">tokType</span> <span class="nx">TokenType</span><span class="p">,</span> <span class="nx">raw</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">tokType</span><span class="p">.</span><span class="nf">IsOpen</span><span class="p">():</span>
        <span class="nx">snapshot</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">snapshot</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">switchAltBuf</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">tokType</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">WriteIndent</span><span class="p">()</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">writeByte</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="nx">tokType</span><span class="p">))</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">tokType</span><span class="p">,</span> <span class="nx">snapshot</span><span class="p">)</span>
        <span class="nx">b</span><span class="p">.</span><span class="nf">setLastToken</span><span class="p">(</span><span class="nx">tokType</span><span class="p">)</span>

    <span class="k">case</span> <span class="nx">tokType</span><span class="p">.</span><span class="nf">IsClose</span><span class="p">():</span>
        <span class="k">if</span> <span class="nf">isValidKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">addErrorf</span><span class="p">(</span><span class="s">&#34;unexpected key(%s) before close token(%s)&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">tokType</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">snapshot</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">addErrorf</span><span class="p">(</span><span class="s">&#34;unexpected close token(%s)&#34;</span><span class="p">,</span> <span class="nx">tokType</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">skipEmptyStructures</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">lastTok</span><span class="p">.</span><span class="nf">IsOpen</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">restore</span><span class="p">(</span><span class="nx">snapshot</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteNewline</span><span class="p">(</span><span class="nx">tokType</span><span class="p">)</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">WriteIndent</span><span class="p">()</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">writeByte</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="nx">tokType</span><span class="p">))</span>
            <span class="nx">b</span><span class="p">.</span><span class="nf">setLastToken</span><span class="p">(</span><span class="nx">tokType</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="all-tests-are-passing">All tests are passing</h2><p>The package starts with good testing in mind:</p><ul><li>It includes tests for most core functions and many edge cases: <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/scanner_test.go">scanner_test.go</a>, <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/parser_test.go">parser_test.go</a>, <a href="https://github.com/ezpkg/ezpkg/blob/main/iter.json/reconstruct_test.go">reconstruct_test.go</a>.</li><li><a href="https://github.com/ezpkg/ezpkg/tree/main/iter.json/test/data">Test data</a> comes from various sources: <a href="https://github.com/serde-rs/json-benchmark">serde-rs</a>, <a href="http://json.org/JSON_checker/">jsonchecker</a>, <a href="https://github.com/valyala/fastjson">fastjson</a>, <a href="https://github.com/Tencent/rapidjson">rapidjson</a>.</li></ul><p>It&rsquo;s the first release, so there&rsquo;s still room for improvement, like fuzzing or benchmark. But the tests are a good starting point for ensuring the package&rsquo;s core logic working as expected.</p><h2 id="missing-features-and-future-work">Missing features and future work</h2><p>This is just the beginning. There are many more features and improvements that can be added to the package:</p><ul><li>Query complex values: like arrays of objects, nested objects, etc.</li><li>Support reader/writer: to handle large JSON data.</li><li>Support JSONL: to handle line-delimited JSON.</li><li>Support ProtoBuf JSON: to handle JSON data from ProtoBuf.</li><li>Easy to use API: to handle common use cases like filtering, transforming, etc.</li><li>More examples: to show how to use the package in real-world scenarios.</li><li>Optimize, benchmark, and fuzz: to ensure the package is efficient and reliable.</li><li>And many more&hellip;</li></ul><p>If you have any ideas or suggestions, feel free to open <a href="https://github.com/ezpkg/ezpkg/issues">an issue</a> or <a href="https://github.com/ezpkg/ezpkg/pulls">pull request</a>. I&rsquo;d love to hear your feedback and help support your use cases!</p><hr><h2 id="conclusion">Conclusion</h2><p>The <a href="ezpkg.io/iter.json">ezpkg.io/iter.json</a> package empowers Go developers to handle JSON data with precision and efficiency. Whether you need to iterate through complex JSON structures, build new JSON objects dynamically, format or minify data, filter specific fields, or even transform values, <a href="ezpkg.io/iter.json">iter.json</a> offers a flexible and powerful solution.</p><p>I’m excited to share this package with the community as a tool for effective JSON manipulation without the need for fully parsing the data. While it’s still in early development and there’s room for more features, it already works well for many common use cases.</p><p>If you have specific requirements or ideas for improvement, feel free to reach out — I’d love to hear your feedback and help support your use cases! 🥳</p><hr><h3 id="subscribe">Let's stay connected!</h3><div>If you like the post, subscribe to <a href="https://olivernguyen.substack.com/">my newsletter</a> to get latest updates:</div><div id="subscription-form"><iframe src="https://olivernguyen.substack.com/embed" width="100%" height="160" style="border:1px solid #eee;border-radius:4px;box-shadow:1px 1px 2px 0 #eee;background:0 0" frameborder="0" scrolling="no"></iframe></div><h2 id="author">Author</h2><p>I'm Oliver Nguyen. A software maker working mostly in Go and JavaScript. I enjoy learning and seeing a better version of myself each day. Occasionally spin off new open source projects. Share knowledge and thoughts during my journey. <span>Connect with me on <a class="icon" target="_blank" rel="noopener" href="https://github.com/iOliverNguyen"><i class="fab fa-github"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://linkedin.com/in/iOliverNguyen"><i class="fab fa-linkedin"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://x.com/_OliverNguyen"><i class="fab fa-twitter"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="https://iOliverNguyen.medium.com"><i class="fab fa-medium-m"></i> </a>, <a class="icon" target="_blank" rel="noopener" href="mailto:iOliverNguyen@gmail.com"><i class="fas fa-envelope"></i> </a>or <a href="https://olivernguyen.substack.com">subscribe to my posts</a>.</span></p></div></article><div id="header-post"><div class="menu-icons"><a id="menu-icon" href="/w"><i class="fas fa-chevron-left fa-lg"></i> <span class="icon-text">Back</span></a></div><div id="header-toc"><nav id="TableOfContents"><ul><li><a href="#hello-world">Hello World!</a><ul><li><a href="#1-iterating-json">1. Iterating JSON</a></li><li><a href="#2-building-json">2. Building JSON</a></li><li><a href="#3-formatting-json">3. Formatting JSON</a></li><li><a href="#4-adding-line-numbers">4. Adding line numbers</a></li><li><a href="#5-adding-comments">5. Adding comments</a></li><li><a href="#6-filtering-json-and-extracting-values">6. Filtering JSON and extracting values</a></li><li><a href="#7-filtering-json-and-returning-a-new-json">7. Filtering JSON and returning a new JSON</a></li><li><a href="#8-editing-values">8. Editing values</a></li></ul></li><li><a href="#how-it-parses-the-json-data">How it parses the JSON data</a><ul><li><a href="#nexttoken-pulls-the-next-token-from-the-input">NextToken() pulls the next token from the input</a></li><li><a href="#scan-all-tokens-in-a-single-loop">Scan() all tokens in a single loop</a></li><li><a href="#parse-is-a-state-machine-with-a-stack">Parse() is a state machine with a stack</a></li></ul></li><li><a href="#how-it-builds-the-json-data-dynamically">How it builds the JSON data dynamically</a><ul><li><a href="#reconstructing-json-from-rawtoken">Reconstructing JSON from RawToken</a></li><li><a href="#how-to-support-indentation">How to support indentation</a></li><li><a href="#early-implementation-of-builder">Early implementation of Builder</a></li><li><a href="#twisting-builder-code-to-support-more-use-cases">Twisting <code>Builder</code> code to support more use cases</a></li></ul></li><li><a href="#all-tests-are-passing">All tests are passing</a></li><li><a href="#missing-features-and-future-work">Missing features and future work</a></li><li><a href="#conclusion">Conclusion</a></li></ul></nav></div></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul></ul></div><div id="toc-footer" class="tog-footer" style="display:none"><script></script><div class="toc-header"><a href="#">iter.json: A Powerful and Efficient Way to Iterate and Manipulate JSON in Go</a></div><nav id="TableOfContents"><ul><li><a href="#hello-world">Hello World!</a><ul><li><a href="#1-iterating-json">1. Iterating JSON</a></li><li><a href="#2-building-json">2. Building JSON</a></li><li><a href="#3-formatting-json">3. Formatting JSON</a></li><li><a href="#4-adding-line-numbers">4. Adding line numbers</a></li><li><a href="#5-adding-comments">5. Adding comments</a></li><li><a href="#6-filtering-json-and-extracting-values">6. Filtering JSON and extracting values</a></li><li><a href="#7-filtering-json-and-returning-a-new-json">7. Filtering JSON and returning a new JSON</a></li><li><a href="#8-editing-values">8. Editing values</a></li></ul></li><li><a href="#how-it-parses-the-json-data">How it parses the JSON data</a><ul><li><a href="#nexttoken-pulls-the-next-token-from-the-input">NextToken() pulls the next token from the input</a></li><li><a href="#scan-all-tokens-in-a-single-loop">Scan() all tokens in a single loop</a></li><li><a href="#parse-is-a-state-machine-with-a-stack">Parse() is a state machine with a stack</a></li></ul></li><li><a href="#how-it-builds-the-json-data-dynamically">How it builds the JSON data dynamically</a><ul><li><a href="#reconstructing-json-from-rawtoken">Reconstructing JSON from RawToken</a></li><li><a href="#how-to-support-indentation">How to support indentation</a></li><li><a href="#early-implementation-of-builder">Early implementation of Builder</a></li><li><a href="#twisting-builder-code-to-support-more-use-cases">Twisting <code>Builder</code> code to support more use cases</a></li></ul></li><li><a href="#all-tests-are-passing">All tests are passing</a></li><li><a href="#missing-features-and-future-work">Missing features and future work</a></li><li><a href="#conclusion">Conclusion</a></li></ul></nav></div><div id="share-footer" class="tog-footer" style="display:none"><ul><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fiter.json%2f&title=iter.json%3a%20A%20Powerful%20and%20Efficient%20Way%20to%20Iterate%20and%20Manipulate%20JSON%20in%20Go"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fiter.json%2f"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://x.com/share?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fiter.json%2f&text=iter.json%3a%20A%20Powerful%20and%20Efficient%20Way%20to%20Iterate%20and%20Manipulate%20JSON%20in%20Go"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fiter.json%2f&title=iter.json%3a%20A%20Powerful%20and%20Efficient%20Way%20to%20Iterate%20and%20Manipulate%20JSON%20in%20Go"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fiOliverNguyen.github.io%2fw%2fiter.json%2f&t=iter.json%3a%20A%20Powerful%20and%20Efficient%20Way%20to%20Iterate%20and%20Manipulate%20JSON%20in%20Go"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="home" class="icon" href="/w"><i class="fas fa-chevron-left fa-lg" aria-hidden="true"></i> Back</a> <a id="toc" class="icon" href="#" onclick='return $(".tog-footer").toggle(),!1'><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a> <a id="share" class="icon" href="#" onclick='return $(".tog-footer").toggle(),!1'><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2025 Oliver Nguyen.</div><div class="footer-right"><nav><ul></ul></nav></div></footer></div><div class="body-right"></div></body><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script src="/lib/jquery/jquery.min.js"></script><script src="/js/main.js"></script></html>